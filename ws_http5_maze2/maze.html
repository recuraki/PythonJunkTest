<html>
<head>
<title>view</title>

<script>
 var map = [];
 var sizefield = [];
 var posStart = [0, 0];
 var posGoal = [0, 0];
 var sizeCell = 20; // セルサイズ
 var sizeLine = 1; // セルの枠線
 var lineColor =  'rgb(0,0,255)';
 var fillColorBlank = 'rgb(255,255,255)';
 var fillColorDiscard =  'rgb(255,0,0)';
 var fillColorSearching =  'rgb(0,128,0)';
 var fillColorStart =  'rgb(0,255,0)';
 var fillColorGoal =  'rgb(0,255,0)';
 var fillColorWall = 'rgb(0,0,0)';
 var discardCells = [];
 var searchCells = [];
 var solved;
 var ctx;

 var BLANK = 0;
 var WALL = 1;
 var SEARCHED = 2;

 var Solver;

 function init(){
  ctx = document.getElementById("cv1").getContext("2d");
  dummyInit();
  mazeInit();
  dummyMaze();
  solveInit();
  Solver = solve_habatansaku();
  Solver = solve_astar();
  drawMap(ctx);
  sendNext();
}

function dummyInit(){
  sizefield = [13,13];
  posStart = [1,1]
  posGoal = [7,7]
}
function dummyMaze(){
  setWall(1, 2)
  setWall(4, 1)
  setWall(4, 1)
  setWall(2, 5)
  setWall(2, 7)
  setWall(2, 9)
  setWall(4, 3)
  setWall(3, 4)
  setWall(4, 5)
  setWall(4, 7)
  setWall(4, 9)
  setWall(6, 3)
  setWall(6, 7)
  setWall(6, 9)
  setWall(6, 11)
  setWall(7, 2)
  setWall(9, 2)
  setWall(11, 2)
  setWall(7, 6)
  setWall(8, 7)
  setWall(8, 9)}

function mazeInit()
{
  map = []
  var i;
  var j;
  for(i = 0; i < sizefield[1]; i++){
    var line = Array(sizefield[0]);
    line.fill(0);
    map.push(line) 
  }
  // 最上段を1でfill
  map[0] = Array(sizefield[0]).fill(1);

  // まんなか
  for(i = 1; i < sizefield[1] - 1; i++){
    var line = Array(sizefield[0]);
    line[0] = 1;
    line[sizefield[1] - 1] = 1
    // 奇数列の場合
    if(i % 2 == 0){
      for(j = 2; j < sizefield[1] - 2; j = j + 2){
        line[j] = 1
      }
    }
    map[i] = line
  }
  // 最下段を1でfill
  map[sizefield[1] - 1] = Array(sizefield[0]).fill(1);
}

function isWall(x, y){
  if ( (getMap(x,y) & 1) == 1){
    return true
  }
  return false
}

function getMap(x, y){
  return map[y][x];
}

function setWall(x, y){
  l = map[y];
  l[x] = 1;
  map[y] = l;
}

function suggestNextPoss(pos){
  // posから動きうる座標を返す
  var ret = []

  // U
  if (pos[1] != 0){
    if (!isWall(pos[0], pos[1] - 1) ){
      ret.push([pos[0], pos[1] - 1])
    }
  }
  // R
  if (pos[0] != (sizefield[0] - 1)){
    if (!isWall(pos[0] + 1, pos[1]) ){
      ret.push([pos[0] + 1, pos[1]])
    }
  }
  // D
  if (pos[1] != (sizefield[1] - 1)){
    if (!isWall(pos[0], pos[1] + 1 ) ){
      ret.push([pos[0], pos[1] + 1])
    }
  }
  // L
  if (pos[0] != 0){
    if (!isWall(pos[0] - 1, pos[1]) ){
      ret.push([pos[0] - 1, pos[1]])
    }

  }
  return ret;
}

function sendNext()
{
  yieldResult = Solver.next();
  drawMap(ctx);
  // 次の描画を予約
  if(!yieldResult["done"]){
    setTimeout("sendNext()", 75);
  } else {
    console.log("END")
  }
}

function solveInit(){
  for(i = 0; i < sizefield[1]; i++){
    var line = Array(sizefield[0]);
    line.fill(0);
    searchCells.push(line) 
  }
}

function getSearched(x, y){
  return searchCells[y][x];
}

function isSerarched(x, y){
  if ( (getSearched(x,y) & 1) == 1){
    return true
  }
  return false
}

function markSearched(x,y){
  l = searchCells[y];
  l[x] = 1;
  searchCells[y] = l;
}

function* solve_habatansaku(){
  var pos;
  var i;
  var queueSearch = [];
  // queueSearch の要素は[pos, [path] ]のリスト
  queueSearch.push( [posStart, [posStart] ] );
  while(queueSearch.length > 0){
    data = queueSearch.shift() 
    pos = data[0];
    path = data[1]
    console.log("current" + pos)
    nextPoss = suggestNextPoss(pos)
    for(i = 0; i < nextPoss.length; i++){
      next = nextPoss[i]
      if(next[0] == posGoal[0] && next[1] == posGoal[1]){
        yield ( [ true, next] )
        queueSearch = []
      }
      if(isSerarched(next[0], next[1])){
        continue;
      }
      markSearched(next[0], next[1]);
      path.push(next)
      queueSearch.unshift( [next, path])
      //queueSearch.push( [next, path] )
      yield( [false, next] )
    }
  }
}

/*
 *
 * Solver: astar
 *
 */
function astar_hfunc(cur, goal){
  return (Math.abs(cur[0] - goal[0]) + Math.abs(cur[1] - goal[1]))
}

function astar_metric(cur){
  return astar_hfunc(cur, posGoal)
}

function astar_sortalgorithm(x, y){
  if (x[2] < x[1]) {
    return(1);
  }
  else if(x[2] > x[1]){
    return(-1)
  }
}

function* solve_astar(){
  var pos;
  var i;
  var queueSearch = [];
  // queueSearch の要素は[pos, path , metric]のリスト
  queueSearch.push( [posStart, [posStart] , astar_metric(posStart) ] );
  while(queueSearch.length > 0){
    data = queueSearch.shift() 
    pos = data[0];
    path = data[1]
    console.log("current" + pos)
    markSearched(pos[0], pos[1]);
    nextPoss = suggestNextPoss(pos)
    for(i = 0; i < nextPoss.length; i++){
      next = nextPoss[i]
      if(next[0] == posGoal[0] && next[1] == posGoal[1]){
        yield ( [ true, next] )
        queueSearch = []
      }
      if(isSerarched(next[0], next[1])){
        continue;
      }
      path.push(next)
      queueSearch.unshift( [next, path, astar_metric(posStart) ])
      yield( [false, next] )
    }
  }
}
/********************************************************/

function handleResponseInit(dat){
  map = dat["map"];
  posGoal = dat["posGoal"]
  posStart = dat["posStart"]
  discardCells = dat["discardCells"]
  searchCells = dat["searchCells"]
  drawMap(ctx);
}

function handleUpdate(dat){
  console.log("update()")
  searchCellsUpdate = dat["searchCells"]
  console.log(searchCellsUpdate)
  searchCells.push(searchCellsUpdate)
  drawMap(ctx)
}

function handleResponse(dat)
{
  console.log(dat);
  if(dat["method"] == "pong"){
    console.log("PONG");
  }
  if(dat["method"] == "responseoInit"){
    handleResponseInit(dat)
  }
  if(dat["method"] == "update"){
    handleUpdate(dat)
  }
}

function drawMap(ctx){
  ctx.clearRect(0, 0, ctx.width, ctx.height);
  var x, y; // loopcounter
  for(y = 0; y < map.length; y++) {
    for(x = 0; x < map[y].length; x++){
      /* 描画する座標の計算 */
      /* 座標の hex strの int化 */
      value = map[y][x];
      if((value & WALL) == 0){
        drawCell(ctx, [x, y], value, fillColorBlank);
      }
      if(value & WALL){
        drawCell(ctx, [x, y], value, fillColorWall);
      }
      if(isSerarched(x,y)){
        drawCell(ctx, [x, y], value, fillColorSearching);
      }
    }
  }
  //drawCell(ctx, [posStart], map[posStart[0], posStart[1]], fillColorStart)
  drawCell(ctx, posStart, map[posStart[0], posGoal[1]], fillColorStart)
  drawCell(ctx, posGoal, map[posGoal[0], posGoal[1]], fillColorGoal)
}

function drawline(ctx, x1, y1, x2, y2, color)
{
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.strokeStyle = lineColor;
  ctx.closePath();
  ctx.stroke();
}

function drawCell(ctx, posCell, value, color)
{
  pos = [(sizeLine + sizeCell + sizeLine) * posCell[0], (sizeLine + sizeCell + sizeLine) * posCell[1]];
  /* Fill cell as specificated color */
  ctx.beginPath();;
  ctx.fillStyle = color;
  ctx.rect(pos[0] + sizeLine, pos[1] + sizeLine, sizeCell, sizeCell);
  ctx.fill();
  ctx.closePath();
}
</script>

</head>
<body onload="init()">

<canvas id="cv1" width="360" height="360"></canvas>

</body>
</html>
