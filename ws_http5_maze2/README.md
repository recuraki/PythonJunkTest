A*(A star)の実装
===

# 基本アルゴリズム
- Solverはスタート位置(sx, sy)とゴール位置(gx, gu)を既知とする
- 各セルはスタートからの距離f, ゴールまでの推定距離をhとした際に以下の関係のコストCを持つ
  - c = f + h
- fはスタートからの距離を定義する関数である。
- hはゴールまでの距離を推定する関数であり、ヒューリスティック関数と呼ばれる。
  - Solverはゴールの座標を基に計算を行う
- Solverは次の探索を行う際に、現在持つ候補の中から最もコストの低い
- 探索の順番は上、右、下、左である
-

## hに関する考察
### 案1: マンハッタン距離
```
|sx - gx| + |sy - gy|
f = lambda s,g: (x[0]**2) + (x[1]**2)

```
### 案2: 斜め移動を許容する
```
sqrt( pow2(sx - gx) + pow2(sy - gy) )
```

# python memo: ヒューリスティック関数の実装
```
>>> s = (1,2)
>>> g = (10,3)
# マンハッタン距離のヒューリスティック関数
>>> h = lambda s,g: abs(s[0] - g[0]) + abs(s[1] - g[1])
>>> h(s,g)
10
# 斜め移動を許容する最短距離
>>> h = lambda s,g: math.sqrt( (s[0] - g[0])**2  + (s[1] - g[1])**2 )
>>> h(s,g)
9.055385138137417
```

# python memo: sort
```
>>> o = [(1,1),(2,0),(3,0),(100,1),(2,3)]
>>> h  = lambda p: p[0]**2 + p[1]**2
>>> list(map(h, o))
[2, 4, 9, 10001, 13]
>>> sorted(o)
[(1, 1), (2, 0), (2, 3), (3, 0), (100, 1)]
>>> sorted(o, key=h)
[(1, 1), (2, 0), (3, 0), (2, 3), (100, 1)]
```
コストが同じものがあった場合、並び替えは行われない
```
>>> o = [(2,0),(0,2)]
>>> h  = lambda p: p[0]**2 + p[1]**2
>>> sorted(o, key=h)
[(2, 0), (0, 2)]
>>> o = [(0,2),(2,0)]
>>> sorted(o, key=h)
[(0, 2), (2, 0)]
```
